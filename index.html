<!DOCTYPE HTML>
<html>
  <head>
    <meta http-equiv='content-type' content='text/html;charset=UTF-8' />
    <title>(fab) | a pure javascript DSL for building async web apps</title>
    <style>
      h1 {
        background: url(logo.png) 50% 50% no-repeat;
        height: 129px;
        margin: 0;
        text-indent: 9999px;
        overflow: hidden;
      }
      
      h2 {
        text-align: center;    
        margin-bottom: 30px;
        font-family: "Georgia", "Times New Roman", serif;
      }
    
      body {
        font: 13.34px Helvetica, Arial, sans-serif;
      }
      
      code {
        font-size: 16px;
      }
      
      #container {
        line-height: 1.5em;
        font-size: 110%;
        text-align: justify;
        width: 40em;
        margin: 20px auto;
      }
      
    </style>
    <style>
      div.gist {
        margin: 0 1em;
        font-size: 100%;
      }
    
      div.gist-meta {
        visibility: hidden !important;
       
        background: #fff !important;
        border-width: 1px 0 0 1px !important;
        border: 1px solid #DEDEDE !important;
        height: 1.5em !important;
        width: 40em !important;
        margin: -2em -.5em 0 0 !important;
        float: right !important;
        
        position: relative !important;
        z-index: 1000 !important;
      }
       
      div.gist-data {
        border-bottom: 0 !important;
      }
       
      div.gist-file:hover div.gist-meta {
        visibility: visible !important;
      }
    </style>
    
  </head>
  <body>

  <a href="http://github.com/jed/fab"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub" /></a>

  <div id='container'>

    <h1>(fab)</h1>
    <h2>a pure javascript DSL for building async web apps</h2>
    
    <h3 id="intro">Introduction</h3>
    
    <p>
      (fab) is a lightweight (~2KB minified and gzipped) toolkit that makes it easy to build asynchronous web apps. It takes advantage of the flexibility of javascript to create a concise DSL without pre-compilation or magic scope hackery.
    </p>
    
    <p>
      Here's an example of an application running on <a href="http://nodejs.org">node.js</a> (currently the only supported platform). Just create a file like this:
    </p>

    <script src="http://gist.github.com/287475.js?file=hello.js"></script>

    <p>then run it in node:</p>
    
    <script src="http://gist.github.com/287475.js?file=hello.sh"></script>

    <p>
      and hit <code>http://localhost:4011/</code>.
    </p>
    
    <p>
      You can also use (fab) as a standard CommonJS library like this:
    </p>

    <script src="http://gist.github.com/287475.js?file=hello2.js"></script>

    <p>then run it like this:</p>
    
    <script src="http://gist.github.com/287475.js?file=hello2.sh"></script>
    
    <h3>Table of Contents</h3>
    
    <ul>
      <li><a href="#installing">Installing (fab)</a></li>
      <li><a href="#gettingstarted">Getting started</a></li>
      <li><a href="#addingpaths">Adding paths</a></li>
      <li><a href="#nestedpaths">Nesting paths</a></li>
      <li><a href="#regexpaths">Matching paths with regular expressions</a></li>
      <li><a href="#handlingstatuses">Handling error and other status codes</a></li>
      <li><a href="#defininghandlers">Defining handler functions</a></li>
      <li><a href="#asyncandstreaming">Returning asynchronous and streaming responses</a></li>
      <li><a href="#streamingrequests">Handling streaming requests</a></li>
      <li><a href="#usingmiddleware">Using middleware</a></li>
      <li><a href="#whatsnext">What's next</a></li>
      <li><a href="#feedback">Feedback</a></li>
      <li><a href="#license">License</a></li>
    </ul>
    
    <h3 id="installing">Installing (fab)</h3>
    
    <p>
      Once you've installed <a href="http://nodejs.org">node.js</a>, download (fab) <a href="http://github.com/jed/fab/archives/master">here</a>, or clone it using git:
    </p>

    <script src="http://gist.github.com/287475.js?file=clone.sh"></script>
    
    <p>
      All of the following examples assume you're in the directory that contains the (fab) repository.
    </p>
    
    <h3 id="gettingstarted">Getting started</h3>
    
    <p>
      To get a better understanding of how (fab) works, let's start with the bare minimum. Here's the smallest possible (fab) app:
    </p>

    <script src="http://gist.github.com/287475.js?file=empty.js"></script>
    
    <p>
      Yep, that's it. This returns a listener: a function that receives HTTP requests and returns HTTP responses. But since we haven't defined any paths, it'll just respond to everything with a 404.
    </p>
    
    <h3 id="addingpaths">Adding paths</h3>
    
    <p>
      So now let's add a path, to get our original hello world application:
    </p>

    <script src="http://gist.github.com/287475.js?file=hello.js"></script>
    
    <p>
      This will return <code>hello!</code> for any <code>GET</code> request on the <code>/hello</code> path, and a 404 for anything else. The string <code>hello world</code> is just a shortcut, and is automatically turned into a function, so the following is identical:
    </p>

    <script src="http://gist.github.com/287475.js?file=helloFunction.js"></script>
    
    <p>
      Let's add another path:
    </p>

    <script src="http://gist.github.com/287475.js?file=helloWorld.js"></script>
    
    <p>
      Now our app responds to both paths.
    </p>
    
    <h3 id="nestedpaths">Nesting paths</h3>
    
    <p>
      For paths with a common prefix, like the two above, we can take advantage of (fab)'s hierarchy; like folders in a filesystem, (fab) paths can contain other paths. So this is identical:
    </p>

    <script src="http://gist.github.com/287475.js?file=helloNested.js"></script>
    
    <p>
      We've added three new ideas here:
    </p>
    
    <ol>
      <li>
        When a single string (<code>/hello</code> in this case) is passed as an argument, it returns a new subpath context.
      </li>
      <li>
        <code>[ "GET" ]</code> can be used to bind to <code>GET</code> requests on the current context. All other common http methods (<code>HEAD</code>, <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>TRACE</code>, <code>OPTIONS</code>, and <code>CONNECT</code>) are also available, as well as the catch-all <code>*</code>. Since <code>[ "GET" ]</code> is just a reference to the <code>GET</code> method, we can also substitute it with the more conventional <code>.GET</code>.
      </li>
      <li>
        The empty call <code>()</code> returns the previous context, which in this case is the root of our app.
      </li>
    </ol>
    
    <h3 id="regexpaths">Matching paths with regular expressions</h3>
    
    <p>
      Regular expressions can also be used instead of strings, for binding handlers on matching paths:
    </p>

    <script src="http://gist.github.com/287475.js?file=helloRegExp.js"></script>
    
    <p>
      The results of substring matches are available to function handlers too, through the <code>capture</code> object on <code>this</code> in the handler. This allows us to return dynamic results:
    </p>

    <script src="http://gist.github.com/287475.js?file=helloCapture.js"></script>
    
    <p>
      so that a <code>GET</code> request to <code>/hello/jed</code> would return <code>hello, jed!</code>.
    </p>
    
    <h3 id="handlingstatuses">Handling error and other status codes</h3>
    
    <p>
      (fab) also lets us define how we want status codes to be handled, for each level of our app:
    </p>

    <script src="http://gist.github.com/287475.js?file=helloStatus.js"></script>
    
    <p>
      This allows us to define more meaningful status handlers that are local to each path. When a status is thrown, (fab) will walk up the hierarchy and call the first status handler it finds.
    <p>
    
    <h3 id="defininghandlers">Defining handler functions</h3>
    
    <p>
      Since returning static strings isn't very useful, let's talk about function handlers. Here's what every handler has available for every request:
    </p>
    
    <ul>
      <li><code>this.method</code>: the HTTP method for the request</li>
      <li><code>this.headers</code>: the HTTP headers for the request</li>
      <li><code>this.url</code>: the request url, parsed into components, like <code>query</code> and <code>capture</code></li>
    </ul>
    
    <p>
      We can use this information to return any of the following:
    </p>
    
    <ul>
      <li>
        a number (such as <code>404</code>), which will invoke the appropriate status handler,
      </li>
      <li>
        an object (such as <code>{ "Location": "http://nodejs.org" }</code>), which is used to set response headers,
      </li>
      <li>
        a string (such as <code>"hello!"</code>), which gets written as the response body, or
      </li>
      <li>
        an array containing any or all of the above, which lets us return full responses like this one, which sets the status to 200, sets the <code>Content-Length</code> header to <code>6</code> and the <code>Content-Type</code> header to <code>text/plain</code>, sends a body with <code>hello!</code>, and finishes the response.
      </li>
    </ul>
    
    <script src="http://gist.github.com/287475.js?file=helloArray.js"></script>

    <p>
      Keep in mind that order is important: the status and headers must be included before any body content.
    </p>
    
    <h3 id="asyncandstreaming">Returning asynchronous and streaming responses</h3>
    
    <p>
      In all the examples above, we've used a static string, or a function that returns the response. But in a truly async app, we can't return the response right away; we might be waiting for some database results, or a remote call. Or we might need to wait until the body of a <code>POST</code> response is fully sent before responding.
    </p>
    
    <p>
      That's no problem for (fab). Every function handler is actually passed one argument: a <code>respond</code> function. So we can do this:
    </p>

    <script src="http://gist.github.com/287475.js?file=helloAsync.js"></script>
    
    <p>
      Any arguments passed to this function can be sent as a response whenever the payload is ready, and <code>null</code> is used to finish the response. in fact, any value returned in the previous example is converted into a call to the <code>respond</code> function, so that these are all equivalent:
    </p>

    <script src="http://gist.github.com/287475.js?file=helloEquivalents.js"></script>
    
    <p>
      This allows us to take advantage of the intutive use of <code>return</code>, without requiring synchronicity. keep in mind that if the handler function doesn't return anything, the connection will remain open until <code>respond( null )</code> is called.
    </p>
    
    <h3 id="streamingrequests">Handling streaming requests</h3>
    
    <p>
      So far we've returned numbers, objects, and strings to assemble responses, but there's one more thing we can return: a function. This function becomes a listener for subsequent request events.
    </p>

    <script src="http://gist.github.com/287475.js?file=helloUpload.js"></script>
    
    <p>
      Just like the <code>respond</code> function, the listener function takes one argument: the data payload. if the payload is <code>null</code>, the request is finished and we can return the response.
    </p>
    
    <h3 id="usingmiddleware">Using middleware</h3>
    
    <p>
      (fab) is easy to extend with your own functions:
    </p>

    <script src="http://gist.github.com/287475.js?file=helloMiddleware.js"></script>
    
    <p>
      Any context can be wrapped with a "middleware" wrapper function. This function takes a single argument, the current handler, and returns another handler, which replaces the current handler on the current context.
    </p>

    <p>
      In the above example, the response body is buffered, and then a <code>Content-Length</code> header is added once the response is finished.
    </p>
    
    <p>
      More documentation on this is forthcoming.
    </p>
    
    <h3 id="whatsnext">What's next</h3>

    <p>
      Here are some things i think would be nice to add for future versions of (fab):
    </p>
    
    <ul>
      <li>
        Middleware examples, including basic authentication, header generation for etags, content length, and other basic niceties.
      </li>
      <li>
        Support for other platforms, most importantly browser environments. This would let you run the same (fab) code on both client and server.
      </li>
    </ul>
    
    <h3 id="feedback">Feedback</h3>
    
    <p>
      Feel free to <a href="http://github.com/jed/fab/issues">add an issue</a> if you find a bug, or fork as you'd like and send me a pull request. You can also find me sometimes in #node.js on freenode, or on <a href="http://twitter.com/jedschmidt">@jedschmidt</a> on twitter.
    </p>
    
    <h3 id="license">License</h3>
    
    <p>
      Copyright (c) 2009 Jed Schmidt (<a href="http://jedschmidt.com">http://jedschmidt.com</a>)
    </p>
    
    <p>
      Permission is hereby granted, free of charge, to any person obtaining
      a copy of this software and associated documentation files (the
      'Software'), to deal in the Software without restriction, including
      without limitation the rights to use, copy, modify, merge, publish,
      distribute, sublicense, and/or sell copies of the Software, and to
      permit persons to whom the Software is furnished to do so, subject to
      the following conditions:
    </p>
    
    <p>
      The above copyright notice and this permission notice shall be
      included in all copies or substantial portions of the Software.
    </p>
    
    <p>
      THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
      IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
      CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
      TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
      SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    </p>
  </div>
</body>
</html>